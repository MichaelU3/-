C# 基础

private、 protected、 public、 internal 修饰符的访问权限:
>>>>private: 私有成员，可以被继承，但是不能访问
	protected: 可以在子类

阻止某一个类被其他类继承么:
>>>>使用关键字sealed

一列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少， 用递归算法实现:
>>>>func(30);
>>>>func(n){
        if(n <= 0) return 0;
        else if(n>0 && n<3) return 1;
        else{
                return func(n-1) + func(n-2);
        }
    }

C#中的委托是什么？
>>>>委托：用来传递方法的类型
委托1：
 public delegate int AddDelegate(int a, int b);

    class Program
    {
        public Program()
        {
            AddDelegate add1 = new AddDelegate(Add);
            int c = add1(3, 5);
        }

        public int Add(int a, int b)
        {
            return a + b;
        }

委托2：
public delegate void Callback();

    class Program
    {
        public Program()
        {
            SendEmails(SaveLogOK, SaveLogErr);
        }

        public void SendEmails(Callback success, Callback fail)
        {
            if (true) { success(); }
            else { fail();}
        }

        public void SaveLogOK()
        {
            Console.WriteLine("Success.");
        }

        public void SaveLogErr()
        {
            Console.WriteLine("Fail.");
        }
        
委托3：(匿名方法）
public delegate int AddDelegate(int a, int b);

    class Program
    {
        public Program()
        {
            AddDelegate add1 = new AddDelegate(delegate(int a, int b){ return a + b; });
            int c = add1(3, 5);
        }
委托4：(Func and Action)
Func: 
    class Program
    {
        public Program(string func)
        {
            Func<int, int, int> add = new Func<int, int, int>(delegate(int a, int b){return a + b;});
            int c = add(3, 5);
        }

Action: 
//public delegate void Callback();

    class Program
    {
        public Program()
        {
            SendEmails(SaveLogOK, SaveLogErr);
        }

        //public void SendEmails(Callback success, Callback fail)
        public void SendEmails(Action success, Action fail)
        {
            if (true) { success(); }
            else { fail();}
        }

        public void SaveLogOK()
        {
            Console.WriteLine("Success.");
        }

        public void SaveLogErr()
        {
            Console.WriteLine("Fail.");
        }

委托5：(Lambda表达式)
public Program(string func)
        {
            Func<int, int, int> add = new Func<int, int, int>(delegate(int a, int b) { return a + b; });
            Func<int, int, int> add2 = new Func<int, int, int>((int a, int b) => { return a + b; });
            int c = add(3, 5);
            c = add2(4, 6);
        }

override与重载的区别:
>>>> override: 是对基类中的方法的重写
>>>> 重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要

什么是装箱和拆箱:
>>>> 装箱: 从值类型接口转换到引用类型。
>>>> 拆箱: 从引用类型转换到值类型拆箱。

dotnet中类(class)与结构(struct)的异同:
>>>> Class可以被实例化,属于引用类型,是分配在内存的堆上的
>>>> Struct属于值类型,是分配在内存的栈上的

abstract class和interface有什么区别:
>>>>接口中所有方法必须是抽象的，并且不能指定方法的访问修饰符。
>>>>抽象类中可以有方法的实现，也可以指定方法的访问修饰符。
>>>>抽象类可以有自己的实现，接口却仅有声明，可以有自己的静态数据字段

接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class):
>>>>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数

sleep() 和 wait() 有什么区别:
>>>>sleep()方法是使线程停止一段时间的方法。在sleep 时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非(a)“醒来”的线程具有更高的优先级(b)正在运行的线程因为其它原因而阻塞。
>>>>wait()是线程交互时，如果线程对一个同步对象x 发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。

ADO.net中常用的对象有哪些？分别描述一下。
>>>> Connection 数据库连接对象
>>>> Command 数据库命令
>>>> DataReader 数据读取器
>>>> DataSet 数据集

HashMap和Hashtable的区别:
>>>> HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable.

const和readonly有什么区别:
>>>>const关键字用来声明编译时常量，readonly用来声明运行时常量
